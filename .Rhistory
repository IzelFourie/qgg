plotGS(fit=fitGS,sets=causal)
cvGS <- gsolve( y=y, X=X, W=W, lambda=lambda, validate=validate)
# PRS using BLUP based on REML procedure (including variance component estimation)
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
# PRS using single marker summary statistic (from single marker regression analyses)
fitSM <- lma( y=y, X=X, W=W)
cvSM <- lma( y=y, X=X, W=W, validate=validate)
cvGS
cvGB
cvSM
barplot(fitGB$theta)
barplot(fitGB$g)
hist(fitGB$g)
hist(fitGB$e)
head(fitGB$e)
head(fitGB$g)
library(qgg)
seq(11,100,5)
library(qgg)
install_github("psoerensen/qgg")
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
install_github("psoerensen/qgg")
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
# PRS using BLUP based on Gauss-Seidel procedure
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda)
plotGS(fit=fitGS,sets=causal)
cvGS <- gsolve( y=y, X=X, W=W, lambda=lambda, validate=validate)
# PRS using BLUP based on REML procedure (including variance component estimation)
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
install_github("psoerensen/qgg")
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
# PRS using BLUP based on Gauss-Seidel procedure
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda)
plotGS(fit=fitGS,sets=causal)
cvGS <- gsolve( y=y, X=X, W=W, lambda=lambda, validate=validate)
# PRS using BLUP based on REML procedure (including variance component estimation)
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
# PRS using single marker summary statistic (from single marker regression analyses)
fitSM <- lma( y=y, X=X, W=W)
cvSM <- lma( y=y, X=X, W=W, validate=validate)
cvGS
cvGB
cvSM
library(qgg)
install_github("psoerensen/qgg")
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
# PRS using BLUP based on Gauss-Seidel procedure
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda)
plotGS(fit=fitGS,sets=causal)
cvGS <- gsolve( y=y, X=X, W=W, lambda=lambda, validate=validate)
# PRS using BLUP based on REML procedure (including variance component estimation)
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
# PRS using single marker summary statistic (from single marker regression analyses)
fitSM <- lma( y=y, X=X, W=W)
cvSM <- lma( y=y, X=X, W=W, validate=validate)
cvGS
cvGB
cvSM
library(qgg)
install_github("psoerensen/qgg")
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
# PRS using BLUP based on Gauss-Seidel procedure
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda)
plotGS(fit=fitGS,sets=causal)
cvGS <- gsolve( y=y, X=X, W=W, lambda=lambda, validate=validate)
# PRS using BLUP based on REML procedure (including variance component estimation)
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
# PRS using single marker summary statistic (from single marker regression analyses)
fitSM <- lma( y=y, X=X, W=W)
cvSM <- lma( y=y, X=X, W=W, validate=validate)
cvGS
cvGB
cvSM
rqW <- qr(W[,1:10])
qrW <- qr(W[,1:10])
qr.R(qrW)
R <- qr.R(qrW)
R%*%R
t(R)%*%R
R%*%t(R)
t(R)%*%R
R%*%t(R)
t(R)%*%R
solve(R%*%t(R))
hist(solve(R%*%t(R)))
hist(diag(solve(R%*%t(R))))
hist((solve(R%*%t(R))))
RR <- solve(R%*%t(R))
diag(RR) <- NA
hist(RR)
RR <- solve(R%*%t(R))
hist(RR/(mean(diag(RR))))
hist(RR/(mean(diag(RR))))
Rinv <- solve(qR)
Rinv <- solve(R)
round(Rinv,2)
round(Rinv,6)
round(RR,6)
round(t(Rinv)%*%Rinv,6)
round(RR,6)
for (i in 2:10) {
W[,i] <- W[,i-1] +rnorm(n)
}
cor(W[,1:10])
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
R
solve(R%*%t(R))
round(solve(R%*%t(R)),3)
round(solve(R%*%t(R)),4)
round(solve(R%*%t(R)),6)
hist(solve(R%*%t(R)))
n
1/2000
R
solve(R)%*%R
solve(R)
solve(R%*%t(R))
(R%*%t(R))%*%diag(solve(R))
solve(R%*%t(R))
solve(R%*%t(R))*1000
eigen(R%*%t(R))
solve(R)
solve(R)%*%eigen(R)$vectors
R%*%eigen(R)$vectors
eigen(R)$vectors%*%R
wsvd <- svd(W[,1:10])
str(wsvd)
head(wsvd$u)
head(Q)
wsvd$v
wsvd$d
eigen(R%*%t(R))
solve(R%*%t(R))
diag(R)
1/diag(R)
for (i in 2:10) {
W[,i] <- 99W[,i-1] +rnorm(n)
}
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
for (i in 2:10) {
W[,i] <- 99*W[,i-1] +rnorm(n)
}
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
cor(W[,1:10])
R
W[,1] <- rnorm(n)
for (i in 2:10) {
W[,i] <- 99*W[,i-1] +rnorm(n)
}
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
R
W[,1] <- rnorm(n)
for (i in 2:10) {
W[,i] <- W[,i-1] +rnorm(n)
}
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
R
W[,1] <- rnorm(n)
for (i in 2:10) {
#W[,i] <- W[,i-1] +rnorm(n)
W[,i] <- rnorm(n)
}
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
R
cor(W[,1:10])
solve(cor(W[,1:10]))
cor(W[,1:10])
solve(cor(W[,1:10]))
cor(W[,1:10])
W[,1] <- rnorm(n)
for (i in 2:10) {
#[,i] <- W[,i-1] +rnorm(n)
W[,i] <- rnorm(n)
}
cor(W[,1:10])
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
W[,1] <- rnorm(n)
for (i in 2:10) {
W[,i] <- W[,i-1] +rnorm(n)
#W[,i] <- rnorm(n)
}
cor(W[,1:10])
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
W[,1] <- rnorm(n)
for (i in 2:10) {
W[,i] <- 2*W[,i-1] +rnorm(n)
#W[,i] <- rnorm(n)
}
cor(W[,1:10])
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
W[,1] <- rnorm(n)
for (i in 2:10) {
W[,i] <- 3*W[,i-1] +rnorm(n)
#W[,i] <- rnorm(n)
}
cor(W[,1:10])
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
W[,1] <- rnorm(n)
for (i in 2:10) {
W[,i] <- W[,i-1] +rnorm(n)
#W[,i] <- rnorm(n)
}
cor(W[,1:10])
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
W[,1] <- rnorm(n)
for (i in 2:10) {
W[,i] <- W[,i-1] +rnorm(n)
#W[,i] <- rnorm(n)
}
cor(W[,1:10])
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
W[,1] <- rnorm(n)
for (i in 2:10) {
W[,i] <- W[,i-1] +rnorm(n)
#W[,i] <- rnorm(n)
}
cor(W[,1:10])
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
W[,1] <- rnorm(n)
for (i in 2:10) {
W[,i] <- W[,i-1] +rnorm(n)
#W[,i] <- rnorm(n)
}
cor(W[,1:10])
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
W[,1] <- rnorm(n)
for (i in 2:10) {
W[,i] <- W[,i-1] +rnorm(n)
#W[,i] <- rnorm(n)
}
cor(W[,1:10])
qrW <- qr(W[,1:10])
Q <- qr.Q(qrW)
R <- qr.R(qrW)
solve(t(W)%*%W))
solve(t(W)%*%W)
solve(t(W[,1:10])%*%W[,1:0])
solve(t(W[,1:10])%*%W[,1:10])
round(solve(t(W[,1:10])%*%W[,1:10]),3)
round(solve(t(W[,1:10])%*%W[,1:10]),4)
round(solve(t(W[,1:10])%*%W[,1:10]),5)
round(solve(t(R)%*%R),5)
w <- sample(0:2,100, replcae=TRUE)
w <- sample(0:2,100, replace=TRUE)
w
scale(w)
scale(w-1)
w2 <- scale(w-1)
w1 <- scale(w)
head(w1)
head(w2)
w1
w2
w1
w2
w1
w1[,1]
60*600
36000/3600
3600/6
getLDSets
?seek
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
# PRS using BLUP based on Gauss-Seidel procedure
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda)
plotGS(fit=fitGS,sets=causal)
nsets <- 100
QRlist <- qrSets(W=W,msets=msets,return.level="QR")
msets <- 100
QRlist <- qrSets(W=W,msets=msets,return.level="QR")
str(QRlist)
names(QRlist)
dR <- sapply(QRlist$R,diag)
names(dR)
str(dR)
invR <- lapply(QRlist$R,function(x) {qr.solve(x)})
dR <- sapply(QRlist$R,function(x) {})
invR <- lapply(QRlist$R,function(x) {qr.solve(x)})
str(invR)
invRR <- lapply(QRlist$R,function(x) {solve(t(x)%*%x)})
str(invRR)
str(invR)
diag(invR[[1]])
diag(invRR[[1]])
diag(invR[[1]])
diag(invR[[1]]**2)
diag(invR[[1]])
diag(invRR[[1]])
d1 <- diag(invR[[1]])
d2 <- diag(invRR[[1]])
d1 <- diag(invR[[1]]**2)
head(d1)
head(d2)
plot(d1,d2)
invRR <- lapply(QRlist$R,function(x) {solve(x%*%t(x))})
d2 <- diag(invRR[[1]])
plot(d1,d2)
head(d1)
head(d2)
head(diag(Qrlist$R[[1]]))
head(diag(QRlist$R[[1]]))
head(1/diag(QRlist$R[[1]]))
head((1/diag(QRlist$R[[1]]))**2)
d3 <- ((1/diag(QRlist$R[[1]]))**2)
plot(d2,d3)
plot(d1,d3)
cor(d1,d3)
rlambda <- sapply(QRlist$R,function(x){(1/diag(x))**2})
head(rlambda)
gsqr <- function( y=NULL, X=NULL, W=NULL, sets=NULL, msets=100, lambda=NULL, weights=FALSE, maxit=500, tol=0.0000001) {
QRlist <- qrSets(W=W,msets=msets,return.level="QR")
lambdaR <- sapply(QRlist$R,function(x){(1/diag(x))**2})
lambda <- lambda*lambdaR
fit <- gsru(y=y, X=X, W=QRlist$Q, sets=QRlist$sets, lambda=lambda, weights=weights)
nsets <- length(QRlist$sets)
for ( i in 1:nsets) {
rws <- QRlist$sets[[i]]
#fit$s[rws] <- solve(QRlist$R[[i]])%*%fit$s[rws,1]
fit$s[rws] <- backsolve(QRlist$R[[i]],fit$s[rws,1])
}
return(fit)
}
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda, method="gsqr")
plotGS(fit=fitGS,sets=causal)
head(lambda)
gsqr <- function( y=NULL, X=NULL, W=NULL, sets=NULL, msets=100, lambda=NULL, weights=FALSE, maxit=500, tol=0.0000001) {
QRlist <- qrSets(W=W,msets=msets,return.level="QR")
lambdaR <- sapply(QRlist$R,function(x){(1/diag(x))**2})
lambda <- lambda*(1/lambdaR)
fit <- gsru(y=y, X=X, W=QRlist$Q, sets=QRlist$sets, lambda=lambda, weights=weights)
nsets <- length(QRlist$sets)
for ( i in 1:nsets) {
rws <- QRlist$sets[[i]]
#fit$s[rws] <- solve(QRlist$R[[i]])%*%fit$s[rws,1]
fit$s[rws] <- backsolve(QRlist$R[[i]],fit$s[rws,1])
}
return(fit)
}
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda, method="gsqr")
plotGS(fit=fitGS,sets=causal)
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda, method="gsqr")
plotGS(fit=fitGS,sets=causal)
fitGS$g
head(fitGS$g)
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda)
plotGS(fit=fitGS,sets=causal)
fitGS2 <- gsolve( y=y, X=X, W=W, lambda=lambda, method="gsqr")
plotGS(fit=fitG2S,sets=causal)
head(fitGS$g)
head(fitGS2$g)
head(fitGS$g)
plot(fitGS2$g,fitGS$g)
gsqr <- function( y=NULL, X=NULL, W=NULL, sets=NULL, msets=100, lambda=NULL, weights=FALSE, maxit=500, tol=0.0000001) {
QRlist <- qrSets(W=W,msets=msets,return.level="QR")
lambdaR <- sapply(QRlist$R,function(x){(1/diag(x))**2})
lambda <- lambda*(1/lambdaR)
#fit <- gsru(y=y, X=X, W=QRlist$Q, sets=QRlist$sets, lambda=lambda, weights=weights)
fit <- gsru(y=y, X=X, W=QRlist$Q, sets=NULL, lambda=lambda, weights=weights)
nsets <- length(QRlist$sets)
for ( i in 1:nsets) {
rws <- QRlist$sets[[i]]
#fit$s[rws] <- solve(QRlist$R[[i]])%*%fit$s[rws,1]
fit$s[rws] <- backsolve(QRlist$R[[i]],fit$s[rws,1])
}
return(fit)
}
fitGS2 <- gsolve( y=y, X=X, W=W, lambda=lambda, method="gsqr")
plotGS(fit=fitG2S,sets=causal)
plot(fitGS2$g,fitGS$g)
gsqr
lambdaR <- sapply(QRlist$R,function(x){(diag(x))**2})
head(ambdaR)
head(lambdaR)
lambdaR <- sapply(QRlist$R,function(x){(1/diag(x))**2})
head(lambdaR)
head(lambdaR)*lambda
diag(t(QRlsit$Q[[1]])%*%QRlist$Q[[1]])
diag(t(QRlist$Q[[1]])%*%QRlist$Q[[1]])
t(QRlist$Q[[1]])%*%QRlist$Q[[1]]
QRlist$Q
dim(QRlist$Q[[1]])
(QRlist$Q[[1]])
QRlist <- qrSets(W=W,msets=msets,return.level="QR")
str(QRlist)
t(QRlist$Q[,1:100])%*%QRlist$[,1:100]
t(QRlist$Q[,1:100])%*%QRlist$Q[,1:100]
diag(t(QRlist$Q[,1:100])%*%QRlist$Q[,1:100])
?list
?vector
?gzip
?zip
?Compress
?comPress
?memCompress
