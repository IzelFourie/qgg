solve(t(W[,1:10])%*%W[,1:10])
round(solve(t(W[,1:10])%*%W[,1:10]),3)
round(solve(t(W[,1:10])%*%W[,1:10]),4)
round(solve(t(W[,1:10])%*%W[,1:10]),5)
round(solve(t(R)%*%R),5)
w <- sample(0:2,100, replcae=TRUE)
w <- sample(0:2,100, replace=TRUE)
w
scale(w)
scale(w-1)
w2 <- scale(w-1)
w1 <- scale(w)
head(w1)
head(w2)
w1
w2
w1
w2
w1
w1[,1]
60*600
36000/3600
3600/6
getLDSets
?seek
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
# PRS using BLUP based on Gauss-Seidel procedure
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda)
plotGS(fit=fitGS,sets=causal)
nsets <- 100
QRlist <- qrSets(W=W,msets=msets,return.level="QR")
msets <- 100
QRlist <- qrSets(W=W,msets=msets,return.level="QR")
str(QRlist)
names(QRlist)
dR <- sapply(QRlist$R,diag)
names(dR)
str(dR)
invR <- lapply(QRlist$R,function(x) {qr.solve(x)})
dR <- sapply(QRlist$R,function(x) {})
invR <- lapply(QRlist$R,function(x) {qr.solve(x)})
str(invR)
invRR <- lapply(QRlist$R,function(x) {solve(t(x)%*%x)})
str(invRR)
str(invR)
diag(invR[[1]])
diag(invRR[[1]])
diag(invR[[1]])
diag(invR[[1]]**2)
diag(invR[[1]])
diag(invRR[[1]])
d1 <- diag(invR[[1]])
d2 <- diag(invRR[[1]])
d1 <- diag(invR[[1]]**2)
head(d1)
head(d2)
plot(d1,d2)
invRR <- lapply(QRlist$R,function(x) {solve(x%*%t(x))})
d2 <- diag(invRR[[1]])
plot(d1,d2)
head(d1)
head(d2)
head(diag(Qrlist$R[[1]]))
head(diag(QRlist$R[[1]]))
head(1/diag(QRlist$R[[1]]))
head((1/diag(QRlist$R[[1]]))**2)
d3 <- ((1/diag(QRlist$R[[1]]))**2)
plot(d2,d3)
plot(d1,d3)
cor(d1,d3)
rlambda <- sapply(QRlist$R,function(x){(1/diag(x))**2})
head(rlambda)
gsqr <- function( y=NULL, X=NULL, W=NULL, sets=NULL, msets=100, lambda=NULL, weights=FALSE, maxit=500, tol=0.0000001) {
QRlist <- qrSets(W=W,msets=msets,return.level="QR")
lambdaR <- sapply(QRlist$R,function(x){(1/diag(x))**2})
lambda <- lambda*lambdaR
fit <- gsru(y=y, X=X, W=QRlist$Q, sets=QRlist$sets, lambda=lambda, weights=weights)
nsets <- length(QRlist$sets)
for ( i in 1:nsets) {
rws <- QRlist$sets[[i]]
#fit$s[rws] <- solve(QRlist$R[[i]])%*%fit$s[rws,1]
fit$s[rws] <- backsolve(QRlist$R[[i]],fit$s[rws,1])
}
return(fit)
}
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda, method="gsqr")
plotGS(fit=fitGS,sets=causal)
head(lambda)
gsqr <- function( y=NULL, X=NULL, W=NULL, sets=NULL, msets=100, lambda=NULL, weights=FALSE, maxit=500, tol=0.0000001) {
QRlist <- qrSets(W=W,msets=msets,return.level="QR")
lambdaR <- sapply(QRlist$R,function(x){(1/diag(x))**2})
lambda <- lambda*(1/lambdaR)
fit <- gsru(y=y, X=X, W=QRlist$Q, sets=QRlist$sets, lambda=lambda, weights=weights)
nsets <- length(QRlist$sets)
for ( i in 1:nsets) {
rws <- QRlist$sets[[i]]
#fit$s[rws] <- solve(QRlist$R[[i]])%*%fit$s[rws,1]
fit$s[rws] <- backsolve(QRlist$R[[i]],fit$s[rws,1])
}
return(fit)
}
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda, method="gsqr")
plotGS(fit=fitGS,sets=causal)
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda, method="gsqr")
plotGS(fit=fitGS,sets=causal)
fitGS$g
head(fitGS$g)
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda)
plotGS(fit=fitGS,sets=causal)
fitGS2 <- gsolve( y=y, X=X, W=W, lambda=lambda, method="gsqr")
plotGS(fit=fitG2S,sets=causal)
head(fitGS$g)
head(fitGS2$g)
head(fitGS$g)
plot(fitGS2$g,fitGS$g)
gsqr <- function( y=NULL, X=NULL, W=NULL, sets=NULL, msets=100, lambda=NULL, weights=FALSE, maxit=500, tol=0.0000001) {
QRlist <- qrSets(W=W,msets=msets,return.level="QR")
lambdaR <- sapply(QRlist$R,function(x){(1/diag(x))**2})
lambda <- lambda*(1/lambdaR)
#fit <- gsru(y=y, X=X, W=QRlist$Q, sets=QRlist$sets, lambda=lambda, weights=weights)
fit <- gsru(y=y, X=X, W=QRlist$Q, sets=NULL, lambda=lambda, weights=weights)
nsets <- length(QRlist$sets)
for ( i in 1:nsets) {
rws <- QRlist$sets[[i]]
#fit$s[rws] <- solve(QRlist$R[[i]])%*%fit$s[rws,1]
fit$s[rws] <- backsolve(QRlist$R[[i]],fit$s[rws,1])
}
return(fit)
}
fitGS2 <- gsolve( y=y, X=X, W=W, lambda=lambda, method="gsqr")
plotGS(fit=fitG2S,sets=causal)
plot(fitGS2$g,fitGS$g)
gsqr
lambdaR <- sapply(QRlist$R,function(x){(diag(x))**2})
head(ambdaR)
head(lambdaR)
lambdaR <- sapply(QRlist$R,function(x){(1/diag(x))**2})
head(lambdaR)
head(lambdaR)*lambda
diag(t(QRlsit$Q[[1]])%*%QRlist$Q[[1]])
diag(t(QRlist$Q[[1]])%*%QRlist$Q[[1]])
t(QRlist$Q[[1]])%*%QRlist$Q[[1]]
QRlist$Q
dim(QRlist$Q[[1]])
(QRlist$Q[[1]])
QRlist <- qrSets(W=W,msets=msets,return.level="QR")
str(QRlist)
t(QRlist$Q[,1:100])%*%QRlist$[,1:100]
t(QRlist$Q[,1:100])%*%QRlist$Q[,1:100]
diag(t(QRlist$Q[,1:100])%*%QRlist$Q[,1:100])
?list
?vector
?gzip
?zip
?Compress
?comPress
?memCompress
bedfiles <- "djfæaædæa"
bedfiles
bedfiles[1]
800000*337000
800000*337000/1000000000
800000*337000*8/1000000000
800000*337000/1000000000
269/2
?seek
77/80
library(qgg)
library(qgg)
library(devtools)
install_github("psoerensen/qgg")
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
# PRS using BLUP based on Gauss-Seidel procedure
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda)
plotGS(fit=fitGS,sets=causal)
cvGS <- gsolve( y=y, X=X, W=W, lambda=lambda, validate=validate)
fitGS2 <- gsolve( y=y, X=X, W=W, lambda=lambda, method="gsqr")
plotGS(fit=fitG2S,sets=causal)
cvGS <- gsolve( y=y, X=X, W=W, lambda=lambda, validate=validate)
# PRS using BLUP based on REML procedure (including variance component estimation)
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
# PRS using single marker summary statistic (from single marker regression analyses)
fitSM <- lma( y=y, X=X, W=W)
cvSM <- lma( y=y, X=X, W=W, validate=validate)
cvGS
cvGB
cvSM
is.matrix(validate)
is.vector(validate)
is.list(validate)
is.list(as.data.frame(validate))
as.data.frame(validate)[[1]]
as.data.frame(validate)[[2]]
v <- 1:5
v[[1]]
v[[4]]
is.list(as.data.frame(validate))
length(as.data.frame(validate))
dim(validate)
cvreml <- function(y=NULL, X=NULL, Glist=NULL, G=NULL, theta=NULL, ids=NULL, validate=NULL, maxit=100, tol=0.00001,bin=NULL,nthreads=1,wkdir=getwd(), verbose=FALSE, makeplots=FALSE)
{
n <- length(y)
theta <- yobs <- ypred <- yo <- yp <- NULL
res <- NULL
nv <- length(as.data.frame(validate))
for (i in 1:nv) {
if(is.matrix(validate)) v <- validate[,i]
if(is.list(validate)) v <- validate[[i]]
if(is.vector(validate)) v <- validate[i]
t <- (1:n)[-v]
fit <- remlR( y=y[t], X=X[t,], G=lapply(G,function(x){x[t,t]}), verbose=verbose)
theta <- rbind(theta, as.vector(fit$theta))
np <- length(fit$theta)
ypred <- X[v, ] %*% fit$b
for (j in 1:(np-1)) {
ypred <- ypred + G[[j]][v,t]%*%fit$Py*fit$theta[j]
}
yobs <- y[v]
res <- rbind(res,qcpred(yobs=yobs,ypred=ypred))
yo <- c(yo, yobs)
yp <- c(yp, ypred)
}
res <- as.data.frame(res)
if(is.null(names(G))) names(G) <- paste("G",1:(np-1),sep="")
colnames(theta) <- c(names(G),"E")
theta <- as.data.frame(round(theta,3))
if (makeplots) {
layout(matrix(1:4, ncol = 2))
boxplot(res$Corr, main = "Predictive Ability", ylab = "Correlation")
boxplot(res$MSPE, main = "Prediction Error", ylab = "MSPE")
boxplot(theta, main = "Estimates", ylab = "Variance")
plot(y=yo, x=yp, xlab = "Predicted", ylab = "Observed")
coef <- lm(yo ~ yp)$coef
abline(a = coef[1], b = coef[2], lwd = 2, col = 2, lty = 2)
}
return(list(pred=res,theta=theta))
}
validate <- lapply( 1:5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
validate
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
cvreml <- function(y=NULL, X=NULL, Glist=NULL, G=NULL, theta=NULL, ids=NULL, validate=NULL, maxit=100, tol=0.00001,bin=NULL,nthreads=1,wkdir=getwd(), verbose=FALSE, makeplots=FALSE)
{
n <- length(y)
theta <- yobs <- ypred <- yo <- yp <- NULL
res <- NULL
if (is.matrix(validate)) validate <- as.data.frame(validate)
nv <- length(validate)
for (i in 1:nv) {
if(is.matrix(validate)) v <- validate[,i]
if(is.list(validate)) v <- validate[[i]]
if(is.vector(validate)) v <- validate[i]
t <- (1:n)[-v]
fit <- remlR( y=y[t], X=X[t,], G=lapply(G,function(x){x[t,t]}), verbose=verbose)
theta <- rbind(theta, as.vector(fit$theta))
np <- length(fit$theta)
ypred <- X[v, ] %*% fit$b
for (j in 1:(np-1)) {
ypred <- ypred + G[[j]][v,t]%*%fit$Py*fit$theta[j]
}
yobs <- y[v]
res <- rbind(res,qcpred(yobs=yobs,ypred=ypred))
yo <- c(yo, yobs)
yp <- c(yp, ypred)
}
res <- as.data.frame(res)
if(is.null(names(G))) names(G) <- paste("G",1:(np-1),sep="")
colnames(theta) <- c(names(G),"E")
theta <- as.data.frame(round(theta,3))
if (makeplots) {
layout(matrix(1:4, ncol = 2))
boxplot(res$Corr, main = "Predictive Ability", ylab = "Correlation")
boxplot(res$MSPE, main = "Prediction Error", ylab = "MSPE")
boxplot(theta, main = "Estimates", ylab = "Variance")
plot(y=yo, x=yp, xlab = "Predicted", ylab = "Observed")
coef <- lm(yo ~ yp)$coef
abline(a = coef[1], b = coef[2], lwd = 2, col = 2, lty = 2)
}
return(list(pred=res,theta=theta))
}
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
length(validate)
nv <- length(validate)
cvreml
library(qgg)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
# PRS using BLUP based on REML procedure (including variance component estimation)
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
is.matrix(validate)
is.vector(validate)
cvreml <- function(y=NULL, X=NULL, Glist=NULL, G=NULL, theta=NULL, ids=NULL, validate=NULL, maxit=100, tol=0.00001,bin=NULL,nthreads=1,wkdir=getwd(), verbose=FALSE, makeplots=FALSE)
{
n <- length(y)
theta <- yobs <- ypred <- yo <- yp <- NULL
res <- NULL
if (is.matrix(validate)) validate <- as.data.frame(validate)
nv <- length(validate)
for (i in 1:nv) {
if(is.matrix(validate)) v <- validate[,i]
if(is.list(validate)) v <- validate[[i]]
#if(is.vector(validate)) v <- validate[i]
t <- (1:n)[-v]
fit <- remlR( y=y[t], X=X[t,], G=lapply(G,function(x){x[t,t]}), verbose=verbose)
theta <- rbind(theta, as.vector(fit$theta))
np <- length(fit$theta)
ypred <- X[v, ] %*% fit$b
for (j in 1:(np-1)) {
ypred <- ypred + G[[j]][v,t]%*%fit$Py*fit$theta[j]
}
yobs <- y[v]
res <- rbind(res,qcpred(yobs=yobs,ypred=ypred))
yo <- c(yo, yobs)
yp <- c(yp, ypred)
}
res <- as.data.frame(res)
if(is.null(names(G))) names(G) <- paste("G",1:(np-1),sep="")
colnames(theta) <- c(names(G),"E")
theta <- as.data.frame(round(theta,3))
if (makeplots) {
layout(matrix(1:4, ncol = 2))
boxplot(res$Corr, main = "Predictive Ability", ylab = "Correlation")
boxplot(res$MSPE, main = "Prediction Error", ylab = "MSPE")
boxplot(theta, main = "Estimates", ylab = "Variance")
plot(y=yo, x=yp, xlab = "Predicted", ylab = "Observed")
coef <- lm(yo ~ yp)$coef
abline(a = coef[1], b = coef[2], lwd = 2, col = 2, lty = 2)
}
return(list(pred=res,theta=theta))
}
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
length(validate)
i
i <-1
v <- validate[[i]]
v
cvreml <- function(y=NULL, X=NULL, Glist=NULL, G=NULL, theta=NULL, ids=NULL, validate=NULL, maxit=100, tol=0.00001,bin=NULL,nthreads=1,wkdir=getwd(), verbose=FALSE, makeplots=FALSE)
{
n <- length(y)
theta <- yobs <- ypred <- yo <- yp <- NULL
res <- NULL
#if (is.matrix(validate)) validate <- as.data.frame(validate)
nv <- length(validate)
for (i in 1:nv) {
#if(is.matrix(validate)) v <- validate[,i]
if(is.list(validate)) v <- validate[[i]]
#if(is.vector(validate)) v <- validate[i]
t <- (1:n)[-v]
fit <- remlR( y=y[t], X=X[t,], G=lapply(G,function(x){x[t,t]}), verbose=verbose)
theta <- rbind(theta, as.vector(fit$theta))
np <- length(fit$theta)
ypred <- X[v, ] %*% fit$b
for (j in 1:(np-1)) {
ypred <- ypred + G[[j]][v,t]%*%fit$Py*fit$theta[j]
}
yobs <- y[v]
res <- rbind(res,qcpred(yobs=yobs,ypred=ypred))
yo <- c(yo, yobs)
yp <- c(yp, ypred)
}
res <- as.data.frame(res)
if(is.null(names(G))) names(G) <- paste("G",1:(np-1),sep="")
colnames(theta) <- c(names(G),"E")
theta <- as.data.frame(round(theta,3))
if (makeplots) {
layout(matrix(1:4, ncol = 2))
boxplot(res$Corr, main = "Predictive Ability", ylab = "Correlation")
boxplot(res$MSPE, main = "Prediction Error", ylab = "MSPE")
boxplot(theta, main = "Estimates", ylab = "Variance")
plot(y=yo, x=yp, xlab = "Predicted", ylab = "Observed")
coef <- lm(yo ~ yp)$coef
abline(a = coef[1], b = coef[2], lwd = 2, col = 2, lty = 2)
}
return(list(pred=res,theta=theta))
}
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
cvreml <- function(y=NULL, X=NULL, Glist=NULL, G=NULL, theta=NULL, ids=NULL, validate=NULL, maxit=100, tol=0.00001,bin=NULL,nthreads=1,wkdir=getwd(), verbose=FALSE, makeplots=FALSE)
{
n <- length(y)
theta <- yobs <- ypred <- yo <- yp <- NULL
res <- NULL
#if (is.matrix(validate)) validate <- as.data.frame(validate)
nv <- length(validate)
for (i in 1:nv) {
#if(is.matrix(validate)) v <- validate[,i]
v <- validate[[i]]
#if(is.vector(validate)) v <- validate[i]
t <- (1:n)[-v]
fit <- remlR( y=y[t], X=X[t,], G=lapply(G,function(x){x[t,t]}), verbose=verbose)
theta <- rbind(theta, as.vector(fit$theta))
np <- length(fit$theta)
ypred <- X[v, ] %*% fit$b
for (j in 1:(np-1)) {
ypred <- ypred + G[[j]][v,t]%*%fit$Py*fit$theta[j]
}
yobs <- y[v]
res <- rbind(res,qcpred(yobs=yobs,ypred=ypred))
yo <- c(yo, yobs)
yp <- c(yp, ypred)
}
res <- as.data.frame(res)
if(is.null(names(G))) names(G) <- paste("G",1:(np-1),sep="")
colnames(theta) <- c(names(G),"E")
theta <- as.data.frame(round(theta,3))
if (makeplots) {
layout(matrix(1:4, ncol = 2))
boxplot(res$Corr, main = "Predictive Ability", ylab = "Correlation")
boxplot(res$MSPE, main = "Prediction Error", ylab = "MSPE")
boxplot(theta, main = "Estimates", ylab = "Variance")
plot(y=yo, x=yp, xlab = "Predicted", ylab = "Observed")
coef <- lm(yo ~ yp)$coef
abline(a = coef[1], b = coef[2], lwd = 2, col = 2, lty = 2)
}
return(list(pred=res,theta=theta))
}
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
library(qgg)
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
cvGB
validate
library(qgg)
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
