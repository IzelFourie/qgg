lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
# PRS using BLUP based on Gauss-Seidel procedure
fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda)
plotGS(fit=fitGS,sets=causal)
cvGS <- gsolve( y=y, X=X, W=W, lambda=lambda, validate=validate)
fitGS2 <- gsolve( y=y, X=X, W=W, lambda=lambda, method="gsqr")
plotGS(fit=fitG2S,sets=causal)
cvGS <- gsolve( y=y, X=X, W=W, lambda=lambda, validate=validate)
# PRS using BLUP based on REML procedure (including variance component estimation)
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
# PRS using single marker summary statistic (from single marker regression analyses)
fitSM <- lma( y=y, X=X, W=W)
cvSM <- lma( y=y, X=X, W=W, validate=validate)
cvGS
cvGB
cvSM
is.matrix(validate)
is.vector(validate)
is.list(validate)
is.list(as.data.frame(validate))
as.data.frame(validate)[[1]]
as.data.frame(validate)[[2]]
v <- 1:5
v[[1]]
v[[4]]
is.list(as.data.frame(validate))
length(as.data.frame(validate))
dim(validate)
cvreml <- function(y=NULL, X=NULL, Glist=NULL, G=NULL, theta=NULL, ids=NULL, validate=NULL, maxit=100, tol=0.00001,bin=NULL,nthreads=1,wkdir=getwd(), verbose=FALSE, makeplots=FALSE)
{
n <- length(y)
theta <- yobs <- ypred <- yo <- yp <- NULL
res <- NULL
nv <- length(as.data.frame(validate))
for (i in 1:nv) {
if(is.matrix(validate)) v <- validate[,i]
if(is.list(validate)) v <- validate[[i]]
if(is.vector(validate)) v <- validate[i]
t <- (1:n)[-v]
fit <- remlR( y=y[t], X=X[t,], G=lapply(G,function(x){x[t,t]}), verbose=verbose)
theta <- rbind(theta, as.vector(fit$theta))
np <- length(fit$theta)
ypred <- X[v, ] %*% fit$b
for (j in 1:(np-1)) {
ypred <- ypred + G[[j]][v,t]%*%fit$Py*fit$theta[j]
}
yobs <- y[v]
res <- rbind(res,qcpred(yobs=yobs,ypred=ypred))
yo <- c(yo, yobs)
yp <- c(yp, ypred)
}
res <- as.data.frame(res)
if(is.null(names(G))) names(G) <- paste("G",1:(np-1),sep="")
colnames(theta) <- c(names(G),"E")
theta <- as.data.frame(round(theta,3))
if (makeplots) {
layout(matrix(1:4, ncol = 2))
boxplot(res$Corr, main = "Predictive Ability", ylab = "Correlation")
boxplot(res$MSPE, main = "Prediction Error", ylab = "MSPE")
boxplot(theta, main = "Estimates", ylab = "Variance")
plot(y=yo, x=yp, xlab = "Predicted", ylab = "Observed")
coef <- lm(yo ~ yp)$coef
abline(a = coef[1], b = coef[2], lwd = 2, col = 2, lty = 2)
}
return(list(pred=res,theta=theta))
}
validate <- lapply( 1:5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
validate
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
cvreml <- function(y=NULL, X=NULL, Glist=NULL, G=NULL, theta=NULL, ids=NULL, validate=NULL, maxit=100, tol=0.00001,bin=NULL,nthreads=1,wkdir=getwd(), verbose=FALSE, makeplots=FALSE)
{
n <- length(y)
theta <- yobs <- ypred <- yo <- yp <- NULL
res <- NULL
if (is.matrix(validate)) validate <- as.data.frame(validate)
nv <- length(validate)
for (i in 1:nv) {
if(is.matrix(validate)) v <- validate[,i]
if(is.list(validate)) v <- validate[[i]]
if(is.vector(validate)) v <- validate[i]
t <- (1:n)[-v]
fit <- remlR( y=y[t], X=X[t,], G=lapply(G,function(x){x[t,t]}), verbose=verbose)
theta <- rbind(theta, as.vector(fit$theta))
np <- length(fit$theta)
ypred <- X[v, ] %*% fit$b
for (j in 1:(np-1)) {
ypred <- ypred + G[[j]][v,t]%*%fit$Py*fit$theta[j]
}
yobs <- y[v]
res <- rbind(res,qcpred(yobs=yobs,ypred=ypred))
yo <- c(yo, yobs)
yp <- c(yp, ypred)
}
res <- as.data.frame(res)
if(is.null(names(G))) names(G) <- paste("G",1:(np-1),sep="")
colnames(theta) <- c(names(G),"E")
theta <- as.data.frame(round(theta,3))
if (makeplots) {
layout(matrix(1:4, ncol = 2))
boxplot(res$Corr, main = "Predictive Ability", ylab = "Correlation")
boxplot(res$MSPE, main = "Prediction Error", ylab = "MSPE")
boxplot(theta, main = "Estimates", ylab = "Variance")
plot(y=yo, x=yp, xlab = "Predicted", ylab = "Observed")
coef <- lm(yo ~ yp)$coef
abline(a = coef[1], b = coef[2], lwd = 2, col = 2, lty = 2)
}
return(list(pred=res,theta=theta))
}
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
length(validate)
nv <- length(validate)
cvreml
library(qgg)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
# PRS using BLUP based on REML procedure (including variance component estimation)
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
is.matrix(validate)
is.vector(validate)
cvreml <- function(y=NULL, X=NULL, Glist=NULL, G=NULL, theta=NULL, ids=NULL, validate=NULL, maxit=100, tol=0.00001,bin=NULL,nthreads=1,wkdir=getwd(), verbose=FALSE, makeplots=FALSE)
{
n <- length(y)
theta <- yobs <- ypred <- yo <- yp <- NULL
res <- NULL
if (is.matrix(validate)) validate <- as.data.frame(validate)
nv <- length(validate)
for (i in 1:nv) {
if(is.matrix(validate)) v <- validate[,i]
if(is.list(validate)) v <- validate[[i]]
#if(is.vector(validate)) v <- validate[i]
t <- (1:n)[-v]
fit <- remlR( y=y[t], X=X[t,], G=lapply(G,function(x){x[t,t]}), verbose=verbose)
theta <- rbind(theta, as.vector(fit$theta))
np <- length(fit$theta)
ypred <- X[v, ] %*% fit$b
for (j in 1:(np-1)) {
ypred <- ypred + G[[j]][v,t]%*%fit$Py*fit$theta[j]
}
yobs <- y[v]
res <- rbind(res,qcpred(yobs=yobs,ypred=ypred))
yo <- c(yo, yobs)
yp <- c(yp, ypred)
}
res <- as.data.frame(res)
if(is.null(names(G))) names(G) <- paste("G",1:(np-1),sep="")
colnames(theta) <- c(names(G),"E")
theta <- as.data.frame(round(theta,3))
if (makeplots) {
layout(matrix(1:4, ncol = 2))
boxplot(res$Corr, main = "Predictive Ability", ylab = "Correlation")
boxplot(res$MSPE, main = "Prediction Error", ylab = "MSPE")
boxplot(theta, main = "Estimates", ylab = "Variance")
plot(y=yo, x=yp, xlab = "Predicted", ylab = "Observed")
coef <- lm(yo ~ yp)$coef
abline(a = coef[1], b = coef[2], lwd = 2, col = 2, lty = 2)
}
return(list(pred=res,theta=theta))
}
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
length(validate)
i
i <-1
v <- validate[[i]]
v
cvreml <- function(y=NULL, X=NULL, Glist=NULL, G=NULL, theta=NULL, ids=NULL, validate=NULL, maxit=100, tol=0.00001,bin=NULL,nthreads=1,wkdir=getwd(), verbose=FALSE, makeplots=FALSE)
{
n <- length(y)
theta <- yobs <- ypred <- yo <- yp <- NULL
res <- NULL
#if (is.matrix(validate)) validate <- as.data.frame(validate)
nv <- length(validate)
for (i in 1:nv) {
#if(is.matrix(validate)) v <- validate[,i]
if(is.list(validate)) v <- validate[[i]]
#if(is.vector(validate)) v <- validate[i]
t <- (1:n)[-v]
fit <- remlR( y=y[t], X=X[t,], G=lapply(G,function(x){x[t,t]}), verbose=verbose)
theta <- rbind(theta, as.vector(fit$theta))
np <- length(fit$theta)
ypred <- X[v, ] %*% fit$b
for (j in 1:(np-1)) {
ypred <- ypred + G[[j]][v,t]%*%fit$Py*fit$theta[j]
}
yobs <- y[v]
res <- rbind(res,qcpred(yobs=yobs,ypred=ypred))
yo <- c(yo, yobs)
yp <- c(yp, ypred)
}
res <- as.data.frame(res)
if(is.null(names(G))) names(G) <- paste("G",1:(np-1),sep="")
colnames(theta) <- c(names(G),"E")
theta <- as.data.frame(round(theta,3))
if (makeplots) {
layout(matrix(1:4, ncol = 2))
boxplot(res$Corr, main = "Predictive Ability", ylab = "Correlation")
boxplot(res$MSPE, main = "Prediction Error", ylab = "MSPE")
boxplot(theta, main = "Estimates", ylab = "Variance")
plot(y=yo, x=yp, xlab = "Predicted", ylab = "Observed")
coef <- lm(yo ~ yp)$coef
abline(a = coef[1], b = coef[2], lwd = 2, col = 2, lty = 2)
}
return(list(pred=res,theta=theta))
}
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
cvreml <- function(y=NULL, X=NULL, Glist=NULL, G=NULL, theta=NULL, ids=NULL, validate=NULL, maxit=100, tol=0.00001,bin=NULL,nthreads=1,wkdir=getwd(), verbose=FALSE, makeplots=FALSE)
{
n <- length(y)
theta <- yobs <- ypred <- yo <- yp <- NULL
res <- NULL
#if (is.matrix(validate)) validate <- as.data.frame(validate)
nv <- length(validate)
for (i in 1:nv) {
#if(is.matrix(validate)) v <- validate[,i]
v <- validate[[i]]
#if(is.vector(validate)) v <- validate[i]
t <- (1:n)[-v]
fit <- remlR( y=y[t], X=X[t,], G=lapply(G,function(x){x[t,t]}), verbose=verbose)
theta <- rbind(theta, as.vector(fit$theta))
np <- length(fit$theta)
ypred <- X[v, ] %*% fit$b
for (j in 1:(np-1)) {
ypred <- ypred + G[[j]][v,t]%*%fit$Py*fit$theta[j]
}
yobs <- y[v]
res <- rbind(res,qcpred(yobs=yobs,ypred=ypred))
yo <- c(yo, yobs)
yp <- c(yp, ypred)
}
res <- as.data.frame(res)
if(is.null(names(G))) names(G) <- paste("G",1:(np-1),sep="")
colnames(theta) <- c(names(G),"E")
theta <- as.data.frame(round(theta,3))
if (makeplots) {
layout(matrix(1:4, ncol = 2))
boxplot(res$Corr, main = "Predictive Ability", ylab = "Correlation")
boxplot(res$MSPE, main = "Prediction Error", ylab = "MSPE")
boxplot(theta, main = "Estimates", ylab = "Variance")
plot(y=yo, x=yp, xlab = "Predicted", ylab = "Observed")
coef <- lm(yo ~ yp)$coef
abline(a = coef[1], b = coef[2], lwd = 2, col = 2, lty = 2)
}
return(list(pred=res,theta=theta))
}
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
library(qgg)
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
cvGB
validate
library(qgg)
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
cvreml <- function(y=NULL, X=NULL, Glist=NULL, G=NULL, theta=NULL, ids=NULL, validate=NULL, maxit=100, tol=0.00001,bin=NULL,nthreads=1,wkdir=getwd(), verbose=FALSE, makeplots=FALSE)
{
n <- length(y)
theta <- yobs <- ypred <- yo <- yp <- NULL
res <- NULL
if (is.matrix(validate)) validate <- as.data.frame(validate)
nv <- length(validate)
for (i in 1:nv) {
if(is.matrix(validate)) v <- validate[,i]
if(is.list(validate)) v <- validate[[i]]
#if(is.vector(validate)) v <- validate[i]
t <- (1:n)[-v]
fit <- remlR( y=y[t], X=X[t,], G=lapply(G,function(x){x[t,t]}), verbose=verbose)
theta <- rbind(theta, as.vector(fit$theta))
np <- length(fit$theta)
ypred <- X[v, ] %*% fit$b
for (j in 1:(np-1)) {
ypred <- ypred + G[[j]][v,t]%*%fit$Py*fit$theta[j]
}
yobs <- y[v]
#res <- rbind(res,qcpred(yobs=yobs,ypred=ypred))
yo <- c(yo, yobs)
yp <- c(yp, ypred)
}
res <- as.data.frame(res)
if(is.null(names(G))) names(G) <- paste("G",1:(np-1),sep="")
colnames(theta) <- c(names(G),"E")
theta <- as.data.frame(round(theta,3))
if (makeplots) {
layout(matrix(1:4, ncol = 2))
boxplot(res$Corr, main = "Predictive Ability", ylab = "Correlation")
boxplot(res$MSPE, main = "Prediction Error", ylab = "MSPE")
boxplot(theta, main = "Estimates", ylab = "Variance")
plot(y=yo, x=yp, xlab = "Predicted", ylab = "Observed")
coef <- lm(yo ~ yp)$coef
abline(a = coef[1], b = coef[2], lwd = 2, col = 2, lty = 2)
}
return(list(pred=res,theta=theta))
}
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
# PRS using BLUP based on REML procedure (including variance component estimation)
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
cvGB
validate <- lapply( 1:5, function(x) {sample(1:n, 1)} )
validate
cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
cvGB
theta <- yobs <- ypred <- yo <- yp <- NULL
is.list(1:5)
is.list(as.list(1:5))
is.vector(as.list(1:5))
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
validate <- lapply( 1:5, function(x) {sample(1:n, 1)} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
G <- computeG(W=W)
cvGB <- greml( y=y, X=X, G=list(G=G), validate="LOOCV")
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
validate <- lapply( 1:5, function(x) {sample(1:n, 1)} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
G <- computeG(W=W)
fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
cvGB <- greml( y=y, X=X, G=list(G=G), validate="LOOCV")
cvGB
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
validate <- lapply( 1:5, function(x) {sample(1:n, 1)} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
G <- computeG(W=W)
cvGB <- greml( y=y, X=X, G=list(G=G), validate="LOOCV")
cvGB
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
validate <- lapply( 1:5, function(x) {sample(1:n, 1)} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
G <- computeG(W=W)
cvGB <- greml( y=y, X=X, G=list(G=G), validate="LOOCV")
cvGB
library(qgg)
# Simulate data
m <- 1000
n <- 2000
W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
W <- scale(W)
colnames(W) <- as.character(1:ncol(W))
rownames(W) <- as.character(1:nrow(W))
causal <- sample(1:ncol(W),50)
y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
X <- model.matrix(y~1)
validate <- replicate( 5, sample(1:n, as.integer(n/10)))
validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
validate <- lapply( 1:5, function(x) {sample(1:n, 1)} )
Sg <- 50
Se <- 50
h2 <- Sg/(Sg+Se)
lambda <- Se/(Sg/m)
lambda <- m*(1-h2)/h2
G <- computeG(W=W)
cvGB <- greml( y=y, X=X, G=list(G=G), validate="LOOCV")
cvGB
qcpred(yobs=cvGB$yobs,ypred=cvGB$ypred)
qgg:::qcpred(yobs=cvGB$yobs,ypred=cvGB$ypred)
library(qgg)
