#########################################################################################
# PRS examples using qgg
#########################################################################################

    #install.packages("devtools")
    library(devtools)
    install_github("psoerensen/qgg")

    library(qgg)

    # Simulate data
    m <- 1000
    n <- 2000
    W <- matrix(sample(0:2,n*m, replace=TRUE),ncol=m)
    W <- scale(W)
    colnames(W) <- as.character(1:ncol(W))
    rownames(W) <- as.character(1:nrow(W))
    causal <- sample(1:ncol(W),50)
    y <- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))
    X <- model.matrix(y~1)

    validate <- replicate( 5, sample(1:n, as.integer(n/10)))

    Sg <- 50
    Se <- 50
    h2 <- Sg/(Sg+Se)
    
    lambda <- Se/(Sg/m)
    lambda <- m*(1-h2)/h2

    # PRS using BLUP based on Gauss-Seidel procedure
    fitGS <- gsolve( y=y, X=X, W=W, lambda=lambda)
      plotGS(fit=fitGS,sets=causal)

    cvGS <- gsolve( y=y, X=X, W=W, lambda=lambda, validate=validate)
   
    
    # PRS using BLUP based on REML procedure (including variance component estimation)
    G <- computeG(W=W)
    fitGB <- greml( y=y, X=X, G=list(G=G), verbose=TRUE)
    cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
    
    validate <- replicate( 5, sample(1:n, as.integer(n/10)))
    cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
   
    validate <- lapply( 1:5, function(x) {sample(1:n, as.integer(n/10))} )
    cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
    
    validate <- 1:6
    cvGB <- greml( y=y, X=X, G=list(G=G), validate=validate)
    
    # PRS using single marker summary statistic (from single marker regression analyses)
    fitSM <- lma( y=y, X=X, W=W)
    cvSM <- lma( y=y, X=X, W=W, validate=validate)
 
    cvGS
    cvGB
    cvSM
    
 
    
#    1. For 1 byte integer, it can be dealt with ichar(), e.g.
#    
#    implicit    none
#    character*1      ::  x(:)
#    integer*4    ::  i,data(:)
#    allocate(x(len))        !  len is the length of data record.
#    allocate(data(len))
#    read(unit, *)x
#    do i=1,len
#    data(i) = ichar(x(i))
#    end do
#    end
#    
#    a little correction:
#         
#         integer*4 , allocatable :: data(:)
#    character*1 , allocatable :: x(:)
    